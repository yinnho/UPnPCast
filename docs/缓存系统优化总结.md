# 缓存系统优化总结

## 背景

在UPnPCast库的第七阶段优化计划中，缓存系统的完善是重要的一环。之前的代码中存在多个独立实现的缓存机制，导致内存使用效率低下、代码重复、以及缺乏统一的缓存策略。

## 优化目标

1. 统一所有组件的缓存管理，使用UPnPCacheManager作为唯一缓存入口
2. 优化缓存配置，提高缓存命中率，减少内存占用
3. 添加内存敏感处理，在低内存环境下自动调整缓存策略
4. 实现缓存监控，跟踪缓存效率指标

## 实现内容

### 1. 统一缓存管理

将以下组件的独立缓存实现迁移到UPnPCacheManager：

- ControllerManager中的controllerCache
- DLNACastManagerImpl中的controllerCache
- RemoteDevice中的deviceCache
- DlnaControllerFactory中的controllerCache

例如，ControllerManager的改动前后对比：

```kotlin
// 改动前
private val controllerCache = ConcurrentHashMap<String, DlnaController>()

// 改动后
private val cacheManager = UPnPCacheManager.getInstance()
```

### 2. 优化缓存配置

1. 添加内存级别自适应：
```kotlin
memoryLevel = when {
    memoryClass < 64 -> MemoryLevel.LOW
    memoryClass < 128 -> MemoryLevel.MEDIUM
    else -> MemoryLevel.HIGH
}
```

2. 根据内存级别调整缓存大小：
```kotlin
val factor = when(level) {
    MemoryLevel.LOW -> 0.5
    MemoryLevel.MEDIUM -> 1.0
    MemoryLevel.HIGH -> 2.0
}
```

3. 优化HTTP响应缓存的内存占用计算：
```kotlin
override fun sizeOf(key: String, value: ByteArray): Int {
    // 返回KB为单位的大小，而不是默认的1
    return value.size / 1024 + 1
}
```

### 3. 添加内存敏感处理

1. 定期监控系统内存状态：
```kotlin
cleanupExecutor?.scheduleAtFixedRate({
    val memoryInfo = android.app.ActivityManager.MemoryInfo()
    activityManager.getMemoryInfo(memoryInfo)
    isLowMemory = memoryInfo.lowMemory
    
    if (!wasLowMemory && isLowMemory) {
        shrinkCaches()
    }
}, 1, 5, TimeUnit.MINUTES)
```

2. 低内存情况下减少缓存时间：
```kotlin
val actualExpiration = if (isLowMemory) {
    System.currentTimeMillis() + TimeUnit.HOURS.toMillis(1) // 低内存时只缓存1小时
} else {
    expiration
}
```

3. 内存压力下自动清理低价值缓存项：
```kotlin
if (httpResponseCache.size() > httpResponseCache.maxSize() * 0.8) {
    val leastUsedItems = urlAccessCount.entries
        .sortedBy { it.value.get() }
        .take(httpResponseCache.size() / 5) // 移除20%的最少使用项
        .map { it.key }
    
    leastUsedItems.forEach { url ->
        httpResponseCache.remove(url)
        // ...
    }
}
```

### 4. 实现缓存统计与监控

1. 实现CacheStatistics类：
```kotlin
class CacheStatistics {
    private val hits = AtomicLong(0)
    private val misses = AtomicLong(0)
    private val evictions = AtomicLong(0)
    
    fun recordHit() = hits.incrementAndGet()
    fun recordMiss() = misses.incrementAndGet()
    fun recordEviction() = evictions.incrementAndGet()
    
    fun getHitRate(): Float {
        val totalRequests = hits.get() + misses.get()
        return if (totalRequests > 0) hits.get().toFloat() / totalRequests else 0f
    }
    // ...
}
```

2. 在关键缓存操作中记录统计信息：
```kotlin
val result = deviceCache.get(deviceId)
if (result != null) {
    cacheStats[CacheType.DEVICE]?.recordHit()
} else {
    cacheStats[CacheType.DEVICE]?.recordMiss()
}
```

3. 在缓存淘汰时记录：
```kotlin
override fun entryRemoved(evicted: Boolean, key: String, oldValue: RemoteDevice, newValue: RemoteDevice?) {
    if (evicted) {
        cacheStats[CacheType.DEVICE]?.recordEviction()
    }
}
```

4. 提供缓存摘要信息：
```kotlin
fun getCacheSummary(): String {
    return buildString {
        append("缓存状态摘要:\n")
        append("- 设备缓存: ${deviceCache.size()}/${deviceCache.maxSize()} (命中率: ${formatPercent(cacheStats[CacheType.DEVICE]?.getHitRate() ?: 0f)})\n")
        // ...
    }
}
```

## 效果与收益

1. **统一管理**：所有缓存通过UPnPCacheManager统一管理，简化了代码结构
2. **内存效率**：根据设备内存级别自动调整缓存大小，避免在低内存设备上占用过多内存
3. **自适应优化**：低内存时自动收缩缓存，提高应用稳定性
4. **可监控性**：详细的缓存统计信息，便于性能调优和问题诊断
5. **资源释放**：改进了缓存条目淘汰时的资源释放逻辑，避免内存泄漏

## 遇到的问题与解决方案

1. **类型兼容性**：在将RemoteDevice的缓存迁移到UPnPCacheManager时，需要处理类型转换。解决方案是创建辅助方法getFromCache进行安全转换。

2. **suspend函数调用**：在DlnaControllerFactory中，直接调用controller.stop()函数导致编译错误，因为它是suspend函数。解决方案是改用controller.stopSync()方法。

3. **资源释放**：缓存项被淘汰时需要释放资源。解决方案是重写LruCache的entryRemoved方法，在其中尝试调用release方法释放资源。

## 后续建议

1. 考虑添加磁盘缓存支持，特别是对于较大的HTTP响应和设备描述文件
2. 进一步优化缓存淘汰策略，不仅考虑访问频率，也考虑资源大小和获取成本
3. 为缓存统计添加可视化UI界面，方便开发调试
4. 考虑实现缓存预热机制，提前加载常用的设备和服务描述 