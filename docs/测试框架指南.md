# UPnPCast 测试框架指南

本文档提供 UPnPCast 项目测试框架的使用规范和指南，帮助开发人员理解如何编写高质量、一致的测试。

## 测试框架职责划分

### JUnit 5
- **单元测试**：验证独立组件的功能正确性
- **参数化测试**：使用 `@ParameterizedTest` 进行多参数测试
- **异常测试**：使用 `assertThrows` 验证异常抛出
- **嵌套测试**：使用 `@Nested` 分组相关测试
- **生命周期管理**：使用 `@BeforeEach`、`@AfterEach` 等

### Kotest
- **行为驱动测试**：使用 BDD 风格（`DescribeSpec`、`BehaviorSpec`）
- **数据驱动测试**：使用 `FunSpec`、`StringSpec` 等风格
- **属性测试**：使用 `checkAll` 和 `forAll` 进行属性验证
- **数据表驱动测试**：使用 `table` 进行表格化测试
- **高级断言**：使用 Kotest 丰富的 matchers

## 目录结构规范

```
app/src/test/java/com/yinnho/upnpcast/
├── junit5/        # JUnit 5 测试类
│   ├── unit/      # 基本单元测试
│   └── params/    # 参数化测试
├── kotest/        # Kotest 测试类
│   ├── behavior/  # 行为规范测试
│   └── property/  # 属性测试
└── utils/         # 测试工具类
```

## 命名规范

- **JUnit 5 单元测试**：`*Test.kt`（例如：`DLNAMediaControllerTest.kt`）
- **JUnit 5 参数化测试**：`*ParamsTest.kt`（例如：`MediaInfoParamsTest.kt`）
- **Kotest 规范测试**：`*Spec.kt`（例如：`MediaInfoSpec.kt`）
- **测试工具类**：`*TestUtils.kt`（例如：`MockTestUtils.kt`）

## JUnit 5 测试规范

### 基本测试示例

```kotlin
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.TestInstance
import org.junit.jupiter.api.Assertions.*

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class DLNAMediaControllerTest {

    private lateinit var mediaController: DLNAMediaController
    
    @BeforeEach
    fun setup() {
        mediaController = DLNAMediaController()
    }
    
    @Test
    fun testPlayMedia() {
        // 测试代码
        assertTrue(mediaController.play())
    }
    
    @AfterEach
    fun tearDown() {
        // 清理资源
    }
}
```

### 参数化测试示例

```kotlin
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.CsvSource
import org.junit.jupiter.params.provider.ValueSource

class MediaInfoParamsTest {

    @ParameterizedTest
    @ValueSource(ints = [0, 30, 60, 90])
    fun testFormatTimeMinutes(minutes: Int) {
        val milliseconds = minutes * 60 * 1000L
        val expected = "$minutes:00"
        assertEquals(expected, formatTime(milliseconds))
    }
    
    @ParameterizedTest
    @CsvSource(
        "0, 0:00",
        "60000, 1:00",
        "150000, 2:30"
    )
    fun testFormatTimeWithCsvSource(milliseconds: Long, expected: String) {
        assertEquals(expected, formatTime(milliseconds))
    }
}
```

### 异常测试示例

```kotlin
import org.junit.jupiter.api.Assertions.assertThrows
import org.junit.jupiter.api.Test

class ExceptionTest {

    @Test
    fun testInvalidUrlThrowsException() {
        val controller = DLNAMediaController()
        
        assertThrows(IllegalArgumentException::class.java) {
            controller.playMedia("")
        }
    }
}
```

## Kotest 测试规范

### 行为规范测试示例

```kotlin
import io.kotest.core.spec.style.BehaviorSpec
import io.kotest.matchers.shouldBe

class MediaInfoSpec : BehaviorSpec({
    given("一个MediaInfo对象") {
        val mediaInfo = MediaInfo(
            title = "测试标题",
            artist = "测试艺术家",
            duration = 60000
        )
        
        `when`("获取格式化时间") {
            val formatted = mediaInfo.getFormattedDuration()
            
            then("应正确显示分钟和秒") {
                formatted shouldBe "1:00"
            }
        }
    }
})
```

### StringSpec 风格示例

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

class SimpleMediaInfoSpec : StringSpec({
    "MediaInfo 应该正确存储标题和艺术家" {
        val mediaInfo = MediaInfo(title = "测试标题", artist = "测试艺术家")
        
        mediaInfo.title shouldBe "测试标题"
        mediaInfo.artist shouldBe "测试艺术家"
    }
    
    "MediaInfo toString 应该包含标题" {
        val mediaInfo = MediaInfo(title = "特殊标题123")
        mediaInfo.toString() shouldBe "MediaInfo(title=特殊标题123)"
    }
})
```

### 属性测试示例

```kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.property.checkAll
import io.kotest.property.arbitrary.string
import io.kotest.matchers.shouldBe

class MediaInfoPropertySpec : StringSpec({
    "MediaInfo 应该处理任何有效输入值" {
        checkAll(
            Arb.string(),
            Arb.string()
        ) { title, artist ->
            val mediaInfo = MediaInfo(
                title = title,
                artist = artist
            )
            
            mediaInfo.title shouldBe title
            mediaInfo.artist shouldBe artist
        }
    }
})
```

## Mock 工具使用规范

### TestMockUtils 使用

使用统一的 `TestMockUtils` 工具类创建和管理 mock 对象，避免直接使用 Mockito：

```kotlin
// 创建 mock 对象
val device = TestMockUtils.createMock<RemoteDevice>()

// 设置行为
TestMockUtils.stub(device) { identity.udn }.thenReturn("uuid:test-device")

// 验证方法调用
TestMockUtils.verifyCall(device) { connect() }

// 捕获参数
val captor = TestMockUtils.createCaptor<String>()
TestMockUtils.verifyWithCaptor(mock, captor) { setTitle(it) }
```

## 最佳实践

1. **测试隔离**：每个测试应该独立运行，不依赖其他测试的状态
2. **描述性命名**：测试方法名应清晰描述被测试的功能和预期结果
3. **AAA 模式**：按照 Arrange（准备）、Act（执行）、Assert（断言）的顺序组织测试代码
4. **Mock 依赖**：使用 mock 对象隔离外部依赖
5. **测试边界条件**：包括正常情况、边界条件和错误情况
6. **代码覆盖率**：使用 Jacoco 监控测试覆盖率，核心功能应达到较高覆盖率

## 实施计划

1. 将现有 JUnit 4 测试迁移到 JUnit 5
   - 更新导入语句
   - 替换 JUnit 4 注解为 JUnit 5 注解
   - 更新断言方法

2. 将行为和属性相关测试迁移到 Kotest
   - 识别适合 BDD 风格的测试
   - 重写为 Kotest 规范风格

3. 统一 Mock 使用方式
   - 使用 `TestMockUtils` 替换直接的 Mockito 调用
   - 扩展 `TestMockUtils` 支持 JUnit 5 和 Kotest

4. 组织测试目录结构
   - 创建规范的目录结构
   - 移动测试类到对应目录

## 注意事项

1. 不要混合使用不同测试风格在同一个测试类中
2. 优先使用 JUnit 5 进行简单单元测试
3. 对于复杂行为测试，使用 Kotest 的 BDD 风格
4. 参数化测试优先使用 JUnit 5 的 `@ParameterizedTest`
5. 属性测试优先使用 Kotest 的 `checkAll` 和 `forAll` 