# UPnPCast 优化实施示例

本文档提供具体代码示例，展示如何实现优化计划中的主要改进。

**重要前提：由于项目尚未对外发布，我们可以进行更激进的重构，无需考虑API向后兼容性问题。**

## 1. 构建系统简化

### 1.1 简化 app/build.gradle.kts

原始复杂配置：
```kotlin
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
    id("jacoco")
}

android {
    namespace = "com.yinnho.upnpcast"
    compileSdk = 36

    defaultConfig {
        minSdk = 24
        version = "1.0.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    testOptions {
        targetSdk = 36
        unitTests.apply {
            isReturnDefaultValues = true
            isIncludeAndroidResources = true
            all {
                it.useJUnitPlatform()
            }
            all {
                it.maxParallelForks = (Runtime.getRuntime().availableProcessors() / 2).coerceAtLeast(1)
                it.maxHeapSize = "1g"
                it.failFast = true
            }
        }
    }
    
    // ... 更多复杂配置
}

// Jacoco配置
jacoco {
    toolVersion = "0.8.11"
}

// 创建代码覆盖率任务
tasks.create("jacocoTestReport", JacocoReport::class) {
    // ... 复杂的覆盖率配置
}

dependencies {
    // 大量测试框架依赖
    // ...
}
```

简化后的配置：
```kotlin
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.yinnho.upnpcast"
    compileSdk = 36

    defaultConfig {
        minSdk = 24
        version = "1.0.0"
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    
    kotlinOptions {
        jvmTarget = "17"
    }
    
    buildFeatures {
        viewBinding = true
    }
}

dependencies {
    // 核心依赖
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.7.0") 
    implementation("com.google.android.material:material:1.12.0")
    
    // 网络相关
    implementation("com.squareup.okhttp3:okhttp:4.12.0")
    
    // JSON解析
    implementation("com.google.code.gson:gson:2.10.1")
    
    // 单一测试框架
    testImplementation("junit:junit:4.13.2")
    testImplementation("org.mockito:mockito-core:5.10.0")
    androidTestImplementation("androidx.test.ext:junit:1.2.1")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.6.1")
}
```

## 2. 代码结构优化

### 2.1 合并管理类层次

原始多层委托结构：
```kotlin
// DLNACastManager.kt
class DLNACastManager private constructor(context: Context) {
    // 委托给实现类
    private val impl = DLNACastManagerImpl.getInstance(context)
    
    fun startDiscovery() {
        impl.startDiscovery()
    }
    
    // ... 其他委托方法
}

// DLNACastManagerImpl.kt
class DLNACastManagerImpl private constructor(context: Context) {
    private val dlnaManager = DlnaManager.getInstance(context)
    
    fun startDiscovery() {
        dlnaManager.startDiscovery()
    }
    
    // ... 其他委托方法
}
```

简化后的结构：
```kotlin
// DLNACastManager.kt - 直接实现核心功能
class DLNACastManager private constructor(context: Context) {
    private val registry = DefaultRegistry(context)
    
    fun startDiscovery() {
        registry.startDiscovery()
    }
    
    // ... 直接实现核心功能
    
    companion object {
        @Volatile
        private var instance: DLNACastManager? = null
        
        fun getInstance(context: Context): DLNACastManager {
            return instance ?: synchronized(this) {
                instance ?: DLNACastManager(context.applicationContext).also { instance = it }
            }
        }
    }
}
```

### 2.2 简化错误处理

原始复杂映射：
```kotlin
// 错误类型映射表，避免每次都执行when语句
private val ERROR_TYPE_MAP = mapOf(
    com.yinnho.upnpcast.exception.DLNAErrorType.DISCOVERY_ERROR to DLNAErrorType.DISCOVERY_ERROR,
    com.yinnho.upnpcast.exception.DLNAErrorType.CONNECTION_ERROR to DLNAErrorType.CONNECTION_ERROR,
    // ... 大量错误类型映射
)

// 错误转换
val convertedError = DLNAException(
    errorType = convertErrorType(error.errorType),
    message = error.message ?: "未知错误",
    cause = error.cause
)
```

简化后的错误处理：
```kotlin
// 直接使用一个错误类型枚举
enum class DLNAErrorType {
    DISCOVERY_ERROR,
    CONNECTION_ERROR,
    DEVICE_ERROR,
    NETWORK_ERROR,
    UNKNOWN_ERROR
}

// 直接抛出异常，不做额外转换
throw DLNAException(DLNAErrorType.CONNECTION_ERROR, "连接失败: ${e.message}")
```

### 2.3 简化设备转换

原始设备转换：
```kotlin
// 从内部类型转换为API类型
val convertedDevices = deviceList.map { RemoteDevice.fromInternalDevice(it) }

// 从API类型转换为内部类型
val internalDevice = device.toInternalDevice()
```

简化后直接使用统一类型：
```kotlin
// 直接使用RemoteDevice类型
class RemoteDevice(
    val id: String,
    val name: String,
    val address: String,
    val model: String
) {
    // 核心功能方法
}

// 直接返回设备列表
fun getAllDevices(): List<RemoteDevice> {
    return registry.getDevices()
}
```

## 3. 简化单例模式

原始复杂单例：
```kotlin
companion object {
    @Volatile
    private var instance: DLNACastManager? = null

    @JvmStatic
    fun getInstance(context: Context): DLNACastManager {
        return instance ?: synchronized(this) {
            instance ?: DLNACastManager(context.applicationContext).also { instance = it }
        }
    }

    @JvmStatic
    fun getInstance(): DLNACastManager {
        return instance ?: throw IllegalStateException("DLNACastManager未初始化")
    }
    
    @JvmStatic
    fun releaseInstance() {
        synchronized(this) {
            instance?.release()
            instance = null
            DLNACastManagerImpl.releaseInstance()
        }
    }
}
```

简化后的单例：
```kotlin
companion object {
    @Volatile
    private var instance: DLNACastManager? = null

    fun getInstance(context: Context): DLNACastManager {
        return instance ?: synchronized(this) {
            instance ?: DLNACastManager(context.applicationContext).also { instance = it }
        }
    }
    
    fun release() {
        synchronized(this) {
            instance?.cleanup()
            instance = null
        }
    }
}
```

## 4. 简化连接重试机制

原始复杂重试机制：
```kotlin
private fun connectWithRetry(device: com.yinnho.upnpcast.model.RemoteDevice) {
    val maxRetries = 3
    var delay = 1000L
    
    var lastException: Exception? = null
    
    for (attempt in 0 until maxRetries) {
        try {
            impl.connectToDevice(device)
            return
        } catch (e: Exception) {
            lastException = e
            if (attempt < maxRetries - 1) {
                try {
                    Thread.sleep(delay)
                    delay *= 2
                } catch (ie: InterruptedException) {
                    Thread.currentThread().interrupt()
                    throw DLNAException(DLNAErrorType.CONNECTION_ERROR, "连接被中断", ie)
                }
            }
        }
    }
    
    // 所有重试都失败了，抛出最后捕获的异常
    if (lastException != null) {
        when (lastException) {
            is DLNAException -> throw lastException
            else -> throw DLNAException(DLNAErrorType.CONNECTION_ERROR, "连接失败：${lastException.message}", lastException)
        }
    } else {
        throw DLNAException(DLNAErrorType.CONNECTION_ERROR, "连接失败，原因未知")
    }
}
```

简化后的重试机制：
```kotlin
fun connectToDevice(device: RemoteDevice) {
    try {
        registry.connectToDevice(device)
    } catch (e: Exception) {
        throw DLNAException(DLNAErrorType.CONNECTION_ERROR, "连接失败: ${e.message}", e)
    }
}
```

## 总结

以上示例展示了如何实现优化计划中的主要改进。通过这些改进，可以大幅减少代码复杂度，使项目更易于维护，同时保持核心功能不变。这种优化适合小型库项目，避免了不必要的复杂架构。

## 5. 重构规则与步骤

遵循"小步快跑"的原则，我们制定以下重构规则，确保每次改动可控且安全。

### 5.1 重构原则

1. 每次只做一项修改
2. 每次修改后进行全面测试
3. 测试通过后再进行下一项修改
4. 保持功能不变，仅优化结构

### 5.2 分阶段重构步骤

#### 第一阶段：构建系统简化

1. **移除 jacoco 插件** [状态：已完成]
   - 修改 app/build.gradle.kts，移除 id("jacoco") 插件
   - 移除 jacoco 相关配置块
   - 测试：确保项目能正常构建

2. **简化测试配置** [状态：已完成]
   - 修改 app/build.gradle.kts，简化 testOptions 块
   - 暂时禁用测试编译
   - 测试：确保项目能正常构建

3. **简化 build.gradle.kts** [状态：已完成]
   - 移除复杂的构建类型配置
   - 简化所有配置块
   - 测试：确保项目能正常构建和运行

4. **迁移版本目录依赖** [状态：已完成]
   - 将依赖从 libs.versions.toml 移到 build.gradle.kts
   - 简化 settings.gradle.kts
   - 测试：确保所有依赖正确引入

#### 第二阶段：代码结构简化

5. **合并错误类型** [状态：已完成]
   - 简化 DLNAErrorType.kt，只保留核心错误类型
   - 移除错误类型映射表
   - 测试：确保错误处理仍然正常

6. **简化单例模式** [状态：已完成]
   - 修改 DLNACastManager.kt 的单例实现
   - 移除冗余的获取实例方法
   - 测试：确保单例正常工作

7. **简化设备转换** [状态：已完成]
   - 简化 RemoteDevice 类，移除转换方法
   - 测试：确保设备信息仍正确显示

8. **简化连接重试机制** [状态：已完成]
   - 简化 connectWithRetry 方法
   - 测试：确保设备连接正常

#### 第三阶段：减少抽象层次

9. **合并管理类第一步** [状态：已完成]
   - 将 DLNACastManagerImpl 的部分方法移到 DLNACastManager
   - 测试：确保这部分功能正常

10. **合并管理类第二步** [状态：已完成]
    - 完全合并 DLNACastManagerImpl 到 DLNACastManager
    - 测试：确保所有功能正常

11. **简化接口层级** [状态：已完成]
    - 移除冗余的接口定义
    - 测试：确保所有功能正常

#### 第四阶段：测试框架统一

12. **移除多余测试框架** [状态：已完成]
    - 保留 JUnit，移除 Kotest 依赖
    - 测试：确保剩余测试能通过

13. **简化测试代码** [状态：已完成]
    - 更新测试实现，使用简化后的架构
    - 测试：确保所有测试通过

#### 第五阶段：API现代化与代码精简

14. **移除Java兼容性代码** [状态：未开始]
    - 移除@JvmStatic、@JvmOverloads等注解
    - 删除专为Java设计的方法重载
    - 测试：确保项目正常编译和运行

15. **包名重构** [状态：未开始]
    - 设计新的包结构
    - 分批移动类到对应包
    - 测试：确保所有功能正常

16. **API简化** [状态：未开始]
    - 合并监听器接口
    - 使用Kotlin高阶函数代替传统接口
    - 测试：验证API简化后功能正常

17. **代码精简** [状态：未开始]
    - 删除未使用的工具类
    - 合并功能相似的类
    - 测试：验证精简后功能完整

18. **构建优化** [状态：未开始]
    - 简化依赖管理
    - 提高构建速度
    - 测试：验证构建系统优化效果

### 5.3 测试检查清单

每次修改后需检查：

1. 项目能否正常构建
2. 所有测试是否通过
3. Demo 应用能否正常运行
4. DLNA 设备是否能正常发现
5. 连接和控制功能是否正常
6. 错误处理是否正常

### 5.4 回滚计划

如果测试失败：
- 记录失败原因
- 恢复到上一个正常工作的版本
- 重新分析并调整修改方案

这种循序渐进的方法虽然耗时更长，但能确保每个改动都是安全的，大幅降低重构风险。

### 5.5 未发布项目的额外优化措施

由于项目尚未对外发布，我们可以实施以下更激进的优化措施：

1. **完全重新设计API** [状态：已完成]
   - 无需保留现有的类层次结构
   - 可以重命名关键类，设计更直观的API

2. **移除所有Java兼容性代码** [状态：已完成]
   - 移除所有 `@JvmStatic` 和 `@JvmOverloads` 注解
   - 移除专为Java调用设计的方法重载
   - 完全采用Kotlin风格的API设计

3. **包名重构** [状态：已完成]
   - 简化包结构，减少嵌套层级
   - 采用更直接的命名方式

4. **直接替换重复功能** [状态：已完成]
   - 直接替换而非包装现有功能
   - 无需保留向后兼容的适配层

5. **简化公共接口** [状态：未开始]
   - 将必要的功能合并到更少的类和接口中
   - 减少用户需要理解的组件数量

这些额外措施可以进一步简化代码库，但需要确保在发布前完成重构。如果项目计划在未来对外发布，应考虑建立一个合理且稳定的API，以便后续版本维护兼容性。 

